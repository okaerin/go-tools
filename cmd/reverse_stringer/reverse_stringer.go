package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"text/template"

	"github.com/spf13/cobra"
)

const reverseMappingTemplate = `
// Code generated by "reverse_stringer"; DO NOT EDIT.
package {{.PackageName}}

import "fmt"

var _{{.TypeName}}fromString = map[string]{{.TypeName}}{
	{{- range $k, $v:= .Enums}}
	"{{$k}}": {{$v}},
	{{- end}}
}

func Parse{{.TypeName}}(s string) ({{.TypeName}}, error) {
	if val, ok := _{{.TypeName}}fromString[s]; ok {
		return val, nil
	}

	return 0, fmt.Errorf("invalid {{.TypeName}}: %s", s)
}
`

type templateObject struct {
	PackageName string
	TypeName    string
	Enums       map[string]string
}

type constant struct {
	Name    string
	Value   string
	Comment string
}

var (
	rootCmd = &cobra.Command{
		Use:   "reverse_stringer",
		Short: "a simple reverse mapping generator for stringer",
		RunE: func(cmd *cobra.Command, args []string) error {
			if silenceFlag {
				log.SetOutput(io.Discard)
			}
			return reverseMap()
		},
	}
	enumType        string
	packageName     string
	lineCommentFlag bool
	stdoutFlag      bool
	silenceFlag     bool
)

func main() {
	// Execute the root command
	if err := rootCmd.Execute(); err != nil {
		log.Println(err)
		os.Exit(1)
	}

}

func init() {
	rootCmd.Flags().StringVarP(&enumType, "enum-type", "e", "", "enum type")
	rootCmd.MarkFlagRequired("enum-type")
	rootCmd.Flags().StringVarP(&packageName, "package-name", "p", "", "package containing the enum")
	rootCmd.MarkFlagRequired("package-name")
	rootCmd.Flags().BoolVar(&lineCommentFlag, "line-comment", true, "use the line comment as name")
	rootCmd.Flags().BoolVar(&stdoutFlag, "stdout", false, "write to stdout instead to file")
	rootCmd.Flags().BoolVarP(&silenceFlag, "silent", "s", false, "silent output")
}

func filterEnumAlias(consts []constant) []constant {
	filtered := make([]constant, len(consts))
	n := 0
	for _, v := range consts {
		isAlias := slices.IndexFunc(consts, func(s constant) bool {
			return s.Name == v.Value
		}) > -1
		if !isAlias {
			filtered[n] = v
			n++
		}
	}
	return filtered[:n]
}

func reverseMap() error {
	//find enum file
	results, err := findGoFileContainingEnum(".", enumType, packageName)
	if err != nil {
		log.Printf("%v\n", err)
		os.Exit(1)
	}
	switch len(results) {
	case 0:
		log.Printf(`type "%s" not found`+"\n", enumType)
		os.Exit(1)
	case 1:
	default:
		log.Printf(`ambigous type "%s". %d times found`+"\n", enumType, len(results))
		os.Exit(1)
	}
	path := results[0]
	consts := extractConstants(path, enumType, packageName)
	//create elements to be templated
	tObj := &templateObject{
		PackageName: packageName,
		TypeName:    enumType,
		Enums:       make(map[string]string),
	}
	for _, c := range filterEnumAlias(consts) {
		name := map[bool]string{true: strings.TrimSpace(c.Comment), false: c.Name}[lineCommentFlag]
		tObj.Enums[name] = c.Name
	}
	//create generated file
	var buf bytes.Buffer
	tmpl := template.Must(template.New("reverseMapping").
		Parse(reverseMappingTemplate))
	if err := tmpl.Execute(&buf, tObj); err != nil {
		return err
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("formatting failed: %v", err)
	}
	// Write result
	switch stdoutFlag {
	case false:
		newFile := filepath.Join(filepath.Dir(path), fmt.Sprintf("%s_reverse_string.go", strings.ToLower(enumType)))
		if err := os.WriteFile(newFile, formatted, 0644); err != nil {
			return fmt.Errorf("file write failed: %v", err)
		}
		log.Println("Reverse mapping file generated!")
	case true:
		fmt.Println(string(formatted))
	}

	return nil
}

func findGoFileContainingEnum(path string, targetType string, targetPackage string) ([]string, error) {
	var result []string
	filepath.Walk(path, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}
		// Skip non go files
		if strings.HasSuffix(path, ".go") {
			if containsEnumType(path, targetType, targetPackage) {
				result = append(result, path)
			}
		}
		return nil
	})
	return result, nil
}

func containsEnumType(path string, targetType string, targetPackage string) bool {
	fs := token.NewFileSet()
	node, err := parser.ParseFile(fs, path, nil, parser.AllErrors)
	if err != nil {
		log.Printf("failed to parse file %s: %v", path, err)
		return false
	}
	if node.Name.Name != targetPackage {
		return false
	}
	found := false
	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if ok && typeSpec.Name.Name == targetType {
			found = true
			return false //stop inspection
		}
		return true
	})

	return found
}

func extractConstants(path string, targetType string, targetPackage string) []constant {
	var consts []constant

	fs := token.NewFileSet()
	node, err := parser.ParseFile(fs, path, nil, parser.AllErrors|parser.ParseComments)
	if err != nil {
		log.Printf("failed to parse file %s: %v", path, err)
		return nil
	}
	if node.Name.Name != targetPackage {
		return nil
	}
	ast.Inspect(node, func(n ast.Node) bool {
		// Look for a "GenDecl" node (general declarations like const, var)
		genDecl, ok := n.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.CONST {
			return true
		}

		// Iterate over the specs in the const block
		for _, spec := range genDecl.Specs {
			valueSpec, ok := spec.(*ast.ValueSpec)
			if !ok {
				continue
			}

			// Check if the type matches the target type
			if valueSpec.Type != nil {
				ident, ok := valueSpec.Type.(*ast.Ident)

				if ok && ident.Name == targetType {
					// Collect the constants
					for i, name := range valueSpec.Names {
						value := ""
						if i < len(valueSpec.Values) {
							value = exprToString(valueSpec.Values[i])
						}
						consts = append(consts, constant{
							Name:    name.Name,
							Value:   value,
							Comment: valueSpec.Comment.Text(),
						})
					}
				}
			}
		}
		return true
	})
	return consts
}

// exprToString converts an expression to its string representation
func exprToString(expr ast.Expr) string {
	switch v := expr.(type) {
	case *ast.BasicLit:
		return v.Value
	case *ast.Ident:
		return v.Name
	case *ast.BinaryExpr:
		return fmt.Sprintf("%s %s %s", exprToString(v.X), v.Op, exprToString(v.Y))
	default:
		return ""
	}
}
